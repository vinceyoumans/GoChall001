# Problem 12 — Highly divisible triangular number
“The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, …

Let us list the factors of the first seven triangle numbers:

1: 1
3: 1,3
6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?”

Let’s see how to brute-force it first. The first naive approach would be the following:

package main
import "fmt"
func main() {
n := 1
triangle := 0
for ;; {
triangle += n
numberOfDivisors := 0
for i := 1; i <= triangle; i++ {
if triangle % i == 0 {
numberOfDivisors++
}
}
if numberOfDivisors >= 300 {
fmt.Printf("triangle: %d has %d divisors\n", triangle, numberOfDivisors)
break
}
n++
}
}
The solution is able to find the first number having over 300 divisors in around 13 seconds as shown by the results below:

$ time ./problem12
triangle: 2162160 has 320 divisors
real    0m12.920s
user    0m12.917s
sys 0m0.016s
When trying to find the first number having over 500 divisors, the above algorithm is really, really slow.

Highly composite triangular numbers

After some research and frustration, I found that these numbers are called “Highly composite triangular numbers”. The list can be found in The On-Line Encyclopedia of Integer Sequences. We have our solution there, and the number we are looking for is 76576500.

The overview problem solution gives us the following help:

“It can be improved somewhat by halting divisions when the divisor exceeds the square root of the triangle number. For every exact divisor up to the square root, there is a corresponding divisor above the square root.”

After changing my algorithm with this help, I came up with the following:

package main
import (
"fmt"
"math"
)
func main() {
n := 1
triangle := 0
for {
triangle += n
numberOfDivisors := 0
to := int(math.Sqrt(float64(triangle)))
for i := 1; i <= to; i++ {
if triangle%i == 0 {
numberOfDivisors += 2
}
}
if numberOfDivisors >= 500 {
fmt.Printf("triangle: %d has %d divisors\n", triangle, numberOfDivisors)
break
}
n++
}
}
As shown below, the solution is found in less than a second!

time ./problem12-improved2
triangle: 76576500 has 576 divisors
real    0m0.407s
user    0m0.409s
sys 0m0.000s
